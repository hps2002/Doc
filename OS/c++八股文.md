### C++从代码到程序的执行过程
源代码 -> 预处理 -> 编译 -> 链接 -> 执行

**gcc的编译过程** 预处理：处理宏定义和条件编译 -> 编译：将源代码处理成为汇编代码 -> 汇编：将汇编代码转化位二进制机器码 -> 链接：连接器将目标文件以及库文件连接起来，生成可执行文件。

**执行后：在main函数之前系统做了哪些事？**<br>
* 设置栈指针<br>
* 初始化静态变量和全局变量存放在 `.data段`<br
* 将未初始化的全局变量赋初值，存放在`.bss`段<br>
* 全局对象初始化，调用构造函数<br>
* 传递main函数的参数arg ,argv等<br>
* 执行main函数前调用`__attribute__(constructor)`修饰符修饰的构造函数<br>

**main函数执行后**<br>
* 析构全局对象<br>
* 执行用`atexit`修饰的对象<br>

**程序中有函数重载，函数的匹配原则和顺序是什么？** 名字查找 -> 确定候选函数 -> 寻找最佳匹配

### 类成员的初始化方式？构造函数的执行顺序？

**类成员的初始化方式**：在函数体内进行初始化、通过列表初始化，在冒号后使用初始化列表初始化。
* 在函数体内的初始化时在被分配进内存中后才进行的
* 列表初始化在分配内存空间时就进行初始化，简单来说就是在进入函数体前就已经完成初始化。

**为什么列表初始化成员会快一些？** 因为在函数体内进行初始化相当于赋值操作，会在栈中产生临时对象。而在列表中初始化就是单纯的进行初始化。

**构造函数顺序**：虚拟基类的构造函数 -> 基类的构造函数 -> 类类型成员的构造函数 -> 派生类自己的构造函数

### 关键字和函数
**右值引用**
`type && 对象 = 右值；`，如 `int && a = 2`, 但是不能`int && a = b;`因为b不是右值只是在赋值的时候取b的值作为右值，所以可以使用`std::move()`将b的值转化为将亡值，`int && a = std::move(b)`，调用move函数之后b中存储的值不再是原来的值，而是成为一个空对象。

右值引用的目的是为了消除在赋值的时候发生不必要对象拷贝

**inline修饰符**
使用inline修饰的函数称为内联函数，内联函数的作用是在编译的时候就对函数进行展开，在调用该函数就不需要系统进行函数压栈操作，减少系统运行的开销。但是使用inline修饰函数的时候要注意的是：在使用inline声明函数的同时就要完成函数的实现，因为在编译过程中直接将函数展开，所以在调用的时候不会在栈中给函数分配空间。

**const修饰符**
* 修饰原生类型，int、char...，被const修饰的变量被看作是一个常量，无法修改。如果要修改需要通过`const_cast<type_id> (expression)`强制取出变量的const属性。
* 修饰指针。可以分为`常量指针` 和 `指针常量`两种情况。<br>
`const int *p 或 int const *p`称为常量指针，该指针指向一个常量，被该指针指向的变量看作是一个常量，不能改变。<br>
`int * const p`称为常量指针，该指针指向的地址不能发生变化，但是地址存放的数据可以发生变化。
* 在类中被const修饰的数据成员，需要使用列表初始化。在类中看作是一个常量不能被修改。
* 在类中被const修饰的函数，在该函数中不能修改数据成员。可以访问所有数据对象，可以访问const修饰的成员函数。不能访问没有被const修饰的成员函数或者友元函数，因为不能保证这些被访问且没有被const修饰的函数不会修改数据成员。反之，没有被const修饰的成员函数可以访问所有的成员。
* 使用const修饰的类对象只能访问被const修饰的成员函数，因为其他函数不能保证不会修改数据成员。

**new和malloc的区别** 最大的区别在于new是一个关键字，malloc是一个库函数。`new`是分配并且构造对应类型的内存空间，返回的是一个相应相应类型的指针，如果是数组的话返回分配空间的首地址，分配失败返回一个`NULL`，析构的时候使用`delete`析构单个对象，使用`delete []`析构数组中所有的元素。malloc通过系统调用brk函数和mmap函数进行空间的分配，malloc函数仅仅向系统申请一块空间，但是不进行初始化，malloc在释放的时候使用free释放。使用new分配的空间可以使用free释放空间但是对象不会被释放, 还有序。

**explicit** 隐式转换，隐式转换发生在小到大的过程中，在构造函数加上这个关键字能防止隐式转换，但是explicit关键字只对一个形参的构造函数有效，对多参的构造函数无效。因为多参数无法进行隐式转换，隐式转换发生在使用数据成员类型隐式生成一个对象。

**strcpy和memcpy的区别** 前者复制字符串，后者可以复制任何东西，strcpy不用任何长度，遇到被复制的字符串的结束符才结束，所以容易溢出，而memcpy通过第三参数控制复制的大小。通常复制字符串一般使用strcpy，复制其他类型的话一般使用memcpy。

**volatile** 不会将数据保留在cpu的寄存器中，每次修改之后都会写回内存，每次读取该变量也是直接从内存中读取。一般用于中断服务例程，多任务环境下任务之间的共享标志，存储器映射的硬件寄存器通常也要加上volatile进行说明，因为他每次读取的意义都不相同。

### 类

**内联函数** 在类声明中直接实现成员函数方法，这个函数叫做内联函数。在类外通过inline修饰的成员函数实现也是内联函数，等价于在类声明中实现的函数。

**const成员函数** 对于`被const绑定的对象`无法调用非const的成员函数，因为无法保证成员函数不会修改数据成员，但是`没有被const绑定的对象`可以调用用const修饰的成员函数。

**列表初始化** 被const修饰数据成员需要使用初始化列表初始化，不能在构造函数体中初始化。

**重载运算符** 重载`<<`运算符的时候需要使用友元函数进行重载, 函数原型为`ostream& operator<< (ostream &os, const classtype &a);`

### 继承

**派生类和基类的关系** 基类指针或者引用可以指向派生类调用基类中的方法，但是不能调用派生类的方法。派生类指针不能指向基类。
基类指针指向派生类调用的方法如果设计基类数据成员的话，访问的是派生类中存储的基类数据成员（但是在同时为虚拟继承中两个派生类，共享一个基类，这种情况是否派生类共享基类的同一个地址空间，还不知道，但是我猜测是不会共享同一个地址空间的，因为基类存储空间随着派生类的创建而创建）

可以这种兼容属性通过派生类初始化基类，期间调用用拷贝构造函数。

**virtual关键字** 在类中如果基类中使用了virtual关键字修饰成员函数的话那么程序将根据引用或者指针所指对象的类型调用成员函数，否则程序将根据指针或者引用的类型调用成员函数。换种说法，如果使用virtual修饰的话则进行了动态绑定，会根据动态绑定的对象调用函数。当基类指针调用被virtual修饰的函数时，会根据引用或者指针指向的对象类型进行调用对应的函数。

**虚析构函数的作用** 如果使用基类指针指向派生类的对象，那么在最后进行delete释放空间的时候，只会调用基类的析构函数对空间进行释放，但是不会调用派生类的析构函数释放空间，造成内存泄漏。因此在基类中的析构函数一般要用virtual修饰为虚析构函数，并自己定义释放基类内存的过程。其他情况就会由系统自动调用析构函数。

**虚函数工作原理** 如果在类中声明了虚函数，那么给每个对象添加一个隐藏的成员。隐藏成员是一个指向虚函数表中函数地址的指针。在这个虚函数表中存放了类对象存放虚函数的地址。如果派生类中对基类的虚函数进行重写，那么虚函数表中对应的虚函数地址应该进行更新，如果没有则不用进行更新。如果派生类中声明了新的虚函数，则将该虚函数添加到这个虚函数表中。简单来说，这个虚函数表对于每个类对象都是只有一个，里面存放包含基类以及派生类中最新（重写虚函数更新地址）的虚函数地址。

**如果类中出现了虚函数，类中大小变化？**，如果类中出现了虚函数，那么会在类中隐式增加一个虚函数指针，在64位系统中该指针的大小为8字节，在32位系统中该指针大小为4个字节，所以如果原生类中内存对齐的大小小于虚函数指针大小的话，就需要按照虚函数指针的大小进行对齐。

**内存对齐** 在类或者结构体中，以字节数最大的类型为标准进行对齐，内存对齐的目的是：提高内存命中率、避免硬件异常或者错误的结果，其实还有一个是比价奇怪的：内存对齐可能节省空间，但是也可能会导致缓存未命中。

**c++虚函数用在哪些场景和功能，什么时候多态的运行时还是编译？** 用于子类改变父类的实现方式、运行时的动态绑定，实现多态，虚拟析构函数：保证指向派生类的基类对象能正确的引用或删除派生类对象。C++实现多态是在运行时实现的，在运行时当使用基类指针或者引用调用虚函数，才会根据实际所指向的对象类型动态绑定。

**虚函数和纯虚函数的区别** 纯虚函数值得是在基类中声明在函数声明后面加上` = 0`，必须在派生类中实现的函数, 拥有纯虚函数的基类是抽象类不能进行实例化。虚函数一般指的是在基类中有自己的实现，可以被子类调用或者实现，通过基类指针进行调用或者引用进行间接调用实现多态性。

### vector

**迭代器失效** 在进行尾部操作之后使得vector重新分配了空间的话会导致当前的迭代器失效。

### unordered_map

**将自定义的类作为unordered_map的key** 需要在类中重载`==`运算符用于比较当前的类是否相等，还需要重载将类转换成哈希值的hash函数。根据哈希表的原理进行实现。

**unordered_map和map的使用场景，区别** unordered_map底层数据结构是哈希表，用于快速的查找映射key到value的关系，查找时间复杂度是O(1)，不过不能保证元素的顺序，map底层结构是红黑树，对于有序的插入和查找的时间复杂度都是O(log n)。因为unordered_map需要额外的桶，所以比map占用的空间更大。使用场景上如果对元素顺序(按照key进行排序)有要求的话使用map，如果没有要求的话使用unordered_map能快速处理大量元素.

### map

**将自定义的类作为map的key** 需要在类中重载`<`运算符，因为map的底层结构是红黑树需要比较大小，所以需要重载`<`符号

### 红黑树
红黑两个节点构成，是一颗平衡二叉树，插入查找时间复杂度是O(log n)级别，特性：
- 节点只有红色和黑色两种
- 根节点为黑色，如果节点为红色那么，其子节点必定为黑色。
- 从任意节点到叶子节点中路径上的黑色节点数量相同
- 插入和删除都需要维护红黑树和平衡二叉树的性质

### 匿名函数


### C++11特性

**auto和c++98的模板关系**

### cmake

**cmake过程：** 声明cmake版本，添加编译选项，添加静态库/动态库， 引入外部共享库和头文件, 设置输出路径，添加可执行文件，链接动态库/静态库

**cmake生成可执行文件的代码是？** add_executable(<输出文件名> a.cpp b.cpp ...)

**cmake常用指令:**<br>
**add_definition** 向c、c++添加 -D的一个定义，使用这个之后相当于在c++中定义了一个宏，用来编译对应#ifdef ... #endif代码块。<br>
**add_dependencies** 定义当前target的其他目标依赖，但是要确保在编译target之前，其他的target已经完成编译。<br>
**add_executable** 定义并且添加可执行程序的目标<br>
**add_subdirectory** 在cmake项目中添加子目录<br>
**enable_testing** 用于控制makefile是否产生test目标<br>
**add_test** 添加test的测试文件，可以使用make test对生成的执行进行测试，一般是`add_test(..) 在下一行enable_testing()<br>


### 类型萃取（traits编程技巧）


### 项目相关

**线程池怎么创建？详细到代码** 
用一个线程池类封装线程池的概念，声明消息队列，互斥信号量，线程池指针。不是单例模式进行创建的线程池，应该使用单例模式进行创建防止出现多个线程池<br>

在消息队列中添加元素，不过要注意线程同步问题`对消息队列添加互斥锁, 添加完成之后再解锁`。完成添加之后通过信号量通知有任务要处理。

添加数据库连接池

通过<pthread.h>创建线程池，使用的是创建线程池的使用一个数组用于存放线程，通过指针操作线程。然后通过创建线程创建函数创建每个线程池,并且进行线程分离
```
for (int i = 0; i < thread_nums; i ++)
{
    //创建线程
    if (pthread_create(thread_pool + i, NULL, worker, this) != 0)
    {
        delete[] thread_pool;
        throw std::exception();
    }
    
    //线程分离
    if (pthread_detach(thread_pool[i]))
    {
        delete[] thread_pool;
        throw std::exception();
    }
}
```
设置工作函数，工作函数如果类函数的话要设置成静态，因为成员函数和普通函数的函数签名不同所以要将成员函数设置为静态(静态成员函数没有this指针)。<br>

**唤醒线程通过信号？用了什么头文件和数据结构** 通过封装头文件<semaphore>中的sem_t信号量和sem_wait()、sem_post()函数用于唤醒线程。封装了sem类，构造函数`sem_init()初始化`，`sem_destory()析构`，`sem_wait()尝试获取任务，如果队列为空的话就阻塞`，`sem_post()使得计数 + 1，然后唤醒被阻塞的线程`

**状态机解析http报文怎么做的？解析出来的数据怎么存储？** HTTP报文使用的是从状态机驱动主状态机进行解析http报文，读取一行对行进行判断当前行是什么状态，主状态机的状态有`CHECK_STATE_REQUESTLINE`、`CHECK_STATE_HEADER`、`CHECK_STATE_CONTENT`三个状态。从状态机的状态：`LINE_OK`, `LINE_BAD`, `LINE_OPEN`<br>
从状态机负责读取行，主状态机负责解析行。解析出来的数据存放在每个http类中对用的数据成员进行保存。

**除了reactor模式要有其他模式吗？** 还有proactor模式，proactor模式：异步网络模式，使用异步I/O的方式在发起异步读写请求的时候，系统自动帮我们把数据读写的任务完成，然后通知应用进程直接处理数据。但是在linux下的socket不支持异步I/O。所以linux网络编程多数采取的事Reactor模式。

**epoll使用的哪种模式** 使用的是ET模式（边缘触发）：当被监控的socket中有可读事件发生的时候，服务器会只从epoll_wait中苏醒一次，此时要尽可能地将这些读完，否则会丢失数据。而LT模式（水平触发模式）则是反复的从epoll_wait中苏醒，直到把所有的都读完。使用ET模式比使用LT模式的效率要高，所以ET模式一般搭配非阻塞I/O使用，防止没有数据可读时一直阻塞在读写函数里面。

**TCP什么情况下会出现大量time_wait，哪个阶段出现？**服务端同时断开大量TCP连接的时候会出现这种情况。http没有使用长连接，大量http长连接超时，http长连接请求数量达到上限。 



