## 对于InnoDB引擎，MySQL的一行是怎么存储的
创建一个数据库的时候，会在 `/var/lib/mysql/` 目录下创建一个和数据库同名的目录，将所有的表结构和表数据存放在这个目录里面

数据库目录里面存放的文件：
* db.opt, 用来存放当前字符集和字符校验规则。
* 对于每个表都有两个对应的文件 `表名.frm` 和 `表名.ibd` 。前者用于存储表的结构，主要包含表的结构定义， 后者用于存储对应的表数据。

注：表数据既可以存放在共享表空间文件，也可以存放在独占表空间文件。这个行为受到参数 `innodb_file_per_tabl` 的控制。

表空间的文件结构：

InnoDB引擎的存储结构：文件由若干段组成，段由若干区组成，区由若干页组成，页由若干行组成。

* 行：数据库的记录都是按行存放的，不同的行格式有不同的存储结构。
* 页：页是数据库读取的最小单位。读取的时候按页从磁盘读进内存，页是InnoDB最小的操作单位，一次最少读取一个页面进入内存，最少刷新一个页面回到磁盘。
* 区：大小为1MB，连续的64个页面会被划分为一个区，使用区的目的是为了在B+Tree中相邻节点的物理位置也相邻，减少随机I/O的次数。
* 段：由多个区组成，分为数据段、索引段、回滚段。

**InnoDB引擎的Compact行格式**：

`变长字段长度列表 + NULL值列表 + 记录头信息 + row_id + trx_id + roll_ptr + 列值1 + 列值2 + ··· + 列值n`

其中前3个是 "记录的额外信息" + 后面是 "记录的真实数据";

* 变长字段长度列表：存放变长字段所占的物理空间大小，求出该可变字段实际占用的大小空间，记录在变长字段长度列表中。<br>
记录规则：一个字节有8个bits，当最高位为0的时候表示该可变字段长度的大小占一个字节，当最高位为1的时候说明需要用两个字节的大小来表示该可变字段的长度。且每个可变字段的记录方式是逆序记录<br>
读取规则：逆序读取，如果发现当前读取字节的最高位为1，说明需要与下一个字节进行组合。如，一个变长字段占用的大小为6个字节，则在 `变长字段长度列表` 中记录为 `0x06`; 如果一个变长字段占用的大小为270个字节，则在 `变长字段长度列表中` 记录为 `0x0e81` ，读取0x81发现最高位是1，将最高位变为0后再读取下一个字节0x0e，将两个字节进行组合 `0x10e`表示变长字段占270字节。<br>
如果表中不存在变长字段的话，则不需要变长字段长度列表；


* NULL值列表：只有表可以位NULL的字段才能出现在NULL值列表中。一个字段占用1个bit，一个字节的二进制位表示8个bit，如果不足8个bit则再前面补0，如果表中有9个字段则NULL值列表占用2个字节，综上NULL值列表占用的字节数：表中每个字段对应每个二进制位，字节数向上取整。<br>
记录规则：如果对应的二进制位为空则再NULL值列表中对应的二进制位置1。<br>
当表中的每个字段都用NOT NULL约束的话，就不需要NULL值列表了。

* 记录头信息重要的信息：**delete_mask**是标识此条记录是否被删除、**next_record**下条记录的位置，指向下条记录的"记录头信息"和"真实数据"之间的位置、**record_type**表示当前记录的类型：0是普通记录，1是B+树叶子节点记录，2表示最小记录、3表示最大记录

* row_id, 如果没有主键以及唯一约束的话就需要隐藏字段，否则不需要隐藏字段
* trx_id, 事务id, 表示当前记录时由哪个事务生成的。
* roll_ptr, 此条记录上个版本的指针。

**行溢出后，MySQL的处理**
以Compact格式的行记录在溢出后，数据真实记录的地方保存一部分记录，剩下一部分数据用溢出页存储，溢出页的地址在真实数据处用20字节存储。

Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式发生行溢出之后不会存储一部分列的数据，而是在真实数据处存放一个20自己大小的地址用于指向溢出页，真实数据存放在溢出页中

# B+树

## 数据库页
结构：文件头 + 页头 + 最大记录、最小记录 + 用户记录 + 空闲空间 + 页目录 + 文件尾

**文件头**：表示页的信息<br>
**页头**：表示页的状态信息<br>
**最大记录、最小记录**：两个虚拟的记录，分别表示页中的最小记录和最大记录，这里的最大和最小说的是按索引键排列的最大和最小<br>
**用户记录**：存储行记录的内容
**空闲空间**：页中还没有被使用的空间
**页目录**：记录当前数据页中的相对位置，对记录起到索引的作用
**文件尾**：检验页是否完整

### 对于数据库页中的页目录
首先，我们要知道在用户行记录中是被分成多个记录组的，而页目录中存放的是每个记录组中的地址偏移量（也相当于指向每个用户组的最后一条记录）

**每个用户组**在每个用户组中，最后一条记录就是最大记录（但不是已经删除的组）。

所以在数据页中查找数据，通过二分定位需要查找的记录在页目录中的哪个组中, 具体过程是：定位到组内最大记录小于目标键的前一个组中，开始向下遍历直到找到目标记录。每个组中的记录数不会很多，不用担心出现O(n)；

## B+树的查询机制
建立一个索引，其实是建立一个B+树。

**B+树的特性**
在这个B+树中只有叶子节点是存放数据的，其他的节点都是存放索引的。因此叶子节点是数据页，非叶子节点是索引页。<br>
非叶子节点分为不同层次，通过分层降低每一层的搜索量<br>
每层的所有节点按照键值索引大小排序，构成一个双向链表<br>

**在B+树中查找数据**，在B+树的索引节点中当前节点的行记录的是下一层节点所有索引键的最小值，所以在B+树的索引节点里面记录列表之前其实相当于是区间中左闭右开的关系。在每个节点中都进行二分寻找，直到找到对应的数据页面，然后再数据页面中查找对应的键值。

**聚簇索引和二级索引** 聚簇索引由表中的主键作为键值形成，如果没有主键就由not NULL + unique的列构成。如果没有null + unique的话，将在行记录中row_id自动生成一个隐式自增id作为聚簇索引的键值。

在二级索引中，叶子节点存放的是聚簇的键值，找到键值之后在进行聚簇索引，这个过程叫做&ldquo;回表&rdquo;

如果查询的数据是主键值，那么不需要进行回表操作，直接通过二级索引返回主键值，这个过程叫做“索引覆盖”

## B+树的创建、查找、插入、删除
B+ 树的特性：
* 数据项只在叶子节点中进行保存，在叶子节点中数据项按照主键的大小用一个双向链表进行链接，便于进行范围查询；非叶子节点存放的索引项，
* 树高为k，阶为m。意思是在阶为m的时候，B+树中的每个节点最多只能由m个儿子，m - 1个关键字，如果节点数量查过m个的话要进行，分裂.**分裂的过程**：如果当前节点增加的关键字导致索引数量大于m，那么就从以(m / 2)关键字为父节点进行分割，以左半边为左节点右半边为右节点。

**创建**：在创建中如果根节点中的关键字小于m，那么这个几点就是空节点<br>
**查找**：通过索引进行查找，从根节点开始，在每个节点中查找目标节点的右边界，进入右边界的前一个索引，直到查找到叶子节点。
**插入**：插入时需要找到插入的位置，在当前位置的后面进行插入，如果当前叶子节关键字等于m，则需要发生分裂，分类出来的的关键字作为插入父节点，递归进行该操作直到符合B+树的定义。
**删除**：查找到需要删除的位置，如果查找到需要删除的位置，删除叶子节点以及对应非叶子节点上的索引即可，如果出现非叶子节点的关键字个数小于(m /2)则需要合并到父节点中。



