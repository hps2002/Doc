# 前后缀分解 2023.4.2

凡是看到有最多进行两次的那种基本上都可以使用前后缀分解来做

前后缀分解是经过前面一次遍历找到目标值，再经过从后面开始的倒序遍历找到最终的目标值。

使用前后缀分解的特点必须是：第一次计算和第二次计算是独立的，且第一次计算在第二次计算之前，才能使用这个方法。

结合题目来讲：leetcode题库中的打家劫舍III，链接 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/
```
我们可以先遍历一次求出只进行一次交易的最大值，第二次从后往前遍历，枚举在尽量高的价格将股票卖出求出最大值。

因为第一次已经求出了进行一次交易的时候得到的收益，第二次枚举的是进行第二次交易的分界点，在第i天的时候进行第二次交易，用后面最大的价格减去第i - 1天的价格加上第i - 1天的最大价值就是进行第二次交易的总收益；

枚举第二次交易的过程中记录后面天数价格最高的时候，用价格最高的减去买到的价格就是第i天进行第二次交易收益最大
代码：
int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<int> f(n + 2);
        /*使用minp记录当前价格的最小值，
          并求出只进行一次交易时候的最大收益记录在f[i]中
        */
        for (int i = 1, minp = INT_MAX; i < n; i++)
        {
            f[i] = max(f[i - 1], prices[i - 1] - minp);
            minp = min(minp, prices[i - 1]);
        }

        int ans = 0;
        /*使用maxp记录后面的价格的最大值，
          用后面的最大值减去所有枚举的第二次交易，取第二次交易的最大收益加上f[i],
          其中f[i]是进行一次交易的时候第i天获得的最大收益
        */
        for (int i = n, maxp = 0; i; i--)
        {
            ans = max(ans, maxp + f[i - 1] - prices[i - 1]);
            maxp = max(maxp, prices[i - 1]);
        }
        return ans;
    }
因为第一次交易和第二次交易的都是分开进行的，且第一次交易必定在第二次之前，所以可以使用上述的做法进行对问题的求解，当然这道题也可以用DP来做。

具体的做法等到后面最多交易K次的时候在进行详细的解释吧，现在对最多交易K次的状态转移还不是很理解。

最多进行一次交易，最多两次交易，最多进行K次交易，其实都属于最多进行K次交易的范畴之中。所以只要掌握最多进行K次交易的做法之后，就能通杀了。此外，股票系列会持续更新。
```
